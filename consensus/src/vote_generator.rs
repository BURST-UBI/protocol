//! Vote generator — produces votes for blocks this node has validated.
//!
//! When the node validates a block (e.g. confirms it passes all checks), the
//! vote generator creates a signed vote that can be broadcast to the network.
//! Only nodes that are configured as representatives (with delegated voting
//! weight) should broadcast votes, but any node can generate them locally for
//! testing or pre-staging.

use burst_crypto::sign_message;
use burst_types::{BlockHash, PrivateKey, Signature, WalletAddress};

/// Generates votes for blocks the node has validated.
pub struct VoteGenerator {
    /// This node's representative account.
    pub representative: WalletAddress,
    /// Whether this node is acting as a representative (has delegated weight).
    pub is_representative: bool,
    /// Signing key for vote generation.
    signing_key: PrivateKey,
    /// Monotonically increasing sequence counter for vote ordering.
    sequence: u64,
}

impl VoteGenerator {
    pub fn new(representative: WalletAddress, signing_key: [u8; 32]) -> Self {
        Self {
            representative,
            is_representative: false,
            signing_key: PrivateKey(signing_key),
            sequence: 0,
        }
    }

    /// Generate a non-final vote for a block.
    ///
    /// Non-final votes can be changed later (e.g. if the node sees a
    /// conflicting block with higher priority).
    pub fn generate_vote(&mut self, block_hash: BlockHash) -> GeneratedVote {
        self.sequence += 1;
        let timestamp = current_timestamp_ms();

        let signature = self.sign_vote(&block_hash, false, timestamp, self.sequence);

        GeneratedVote {
            voter: self.representative.clone(),
            block_hash,
            is_final: false,
            timestamp,
            sequence: self.sequence,
            signature,
        }
    }

    /// Generate a final vote (cannot be changed).
    ///
    /// Final votes signal that the representative has made its definitive
    /// choice. Once broadcast, the representative cannot vote differently
    /// for the same election root.
    pub fn generate_final_vote(&mut self, block_hash: BlockHash) -> GeneratedVote {
        self.sequence += 1;
        let timestamp = current_timestamp_ms();

        let signature = self.sign_vote(&block_hash, true, timestamp, self.sequence);

        GeneratedVote {
            voter: self.representative.clone(),
            block_hash,
            is_final: true,
            timestamp,
            sequence: self.sequence,
            signature,
        }
    }

    /// Current sequence number.
    pub fn sequence(&self) -> u64 {
        self.sequence
    }

    /// Sign a vote payload: block_hash ‖ is_final ‖ timestamp ‖ sequence.
    fn sign_vote(
        &self,
        block_hash: &BlockHash,
        is_final: bool,
        timestamp: u64,
        sequence: u64,
    ) -> Signature {
        let mut payload = Vec::with_capacity(32 + 1 + 8 + 8);
        payload.extend_from_slice(block_hash.as_bytes());
        payload.push(u8::from(is_final));
        payload.extend_from_slice(&timestamp.to_le_bytes());
        payload.extend_from_slice(&sequence.to_le_bytes());

        sign_message(&payload, &self.signing_key)
    }
}

/// A vote generated by this node, ready for broadcast.
#[derive(Clone, Debug)]
pub struct GeneratedVote {
    /// The representative account that generated this vote.
    pub voter: WalletAddress,
    /// The block hash being voted for.
    pub block_hash: BlockHash,
    /// Whether this is a final (irrevocable) vote.
    pub is_final: bool,
    /// Timestamp in milliseconds when the vote was generated.
    pub timestamp: u64,
    /// Monotonic sequence number for ordering votes from the same voter.
    pub sequence: u64,
    /// Ed25519 signature over the vote payload.
    pub signature: Signature,
}

impl GeneratedVote {
    /// Serialize for network transmission.
    ///
    /// Wire format: voter (variable) ‖ block_hash (32) ‖ is_final (1)
    ///              ‖ timestamp (8 LE) ‖ sequence (8 LE) ‖ signature (64)
    pub fn to_bytes(&self) -> Vec<u8> {
        let voter_bytes = self.voter.as_str().as_bytes();
        let voter_len = voter_bytes.len() as u16;

        let mut buf = Vec::with_capacity(2 + voter_bytes.len() + 32 + 1 + 8 + 8 + 64);
        buf.extend_from_slice(&voter_len.to_le_bytes());
        buf.extend_from_slice(voter_bytes);
        buf.extend_from_slice(self.block_hash.as_bytes());
        buf.push(u8::from(self.is_final));
        buf.extend_from_slice(&self.timestamp.to_le_bytes());
        buf.extend_from_slice(&self.sequence.to_le_bytes());
        buf.extend_from_slice(&self.signature.0);
        buf
    }
}

/// Helper: current time in milliseconds since epoch.
fn current_timestamp_ms() -> u64 {
    std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap_or_default()
        .as_millis() as u64
}

#[cfg(test)]
mod tests {
    use super::*;
    use burst_crypto::{generate_keypair, verify_signature};
    use burst_types::PublicKey;

    fn make_hash(byte: u8) -> BlockHash {
        BlockHash::new([byte; 32])
    }

    fn make_rep() -> WalletAddress {
        WalletAddress::new("brst_testrep1111111111111111111111111111111111111111111111111111111")
    }

    fn make_generator() -> (VoteGenerator, PublicKey) {
        let kp = generate_keypair();
        let gen = VoteGenerator::new(make_rep(), kp.private.0);
        (gen, kp.public)
    }

    #[test]
    fn generate_vote_increments_sequence() {
        let (mut gen, _) = make_generator();
        assert_eq!(gen.sequence(), 0);

        let v1 = gen.generate_vote(make_hash(1));
        assert_eq!(v1.sequence, 1);
        assert_eq!(gen.sequence(), 1);

        let v2 = gen.generate_vote(make_hash(2));
        assert_eq!(v2.sequence, 2);
        assert_eq!(gen.sequence(), 2);
    }

    #[test]
    fn generate_vote_is_not_final() {
        let (mut gen, _) = make_generator();
        let vote = gen.generate_vote(make_hash(1));
        assert!(!vote.is_final);
        assert_eq!(vote.block_hash, make_hash(1));
        assert_eq!(vote.voter, make_rep());
    }

    #[test]
    fn generate_final_vote_is_final() {
        let (mut gen, _) = make_generator();
        let vote = gen.generate_final_vote(make_hash(1));
        assert!(vote.is_final);
        assert_eq!(vote.block_hash, make_hash(1));
    }

    #[test]
    fn vote_signature_is_valid() {
        let (mut gen, pubkey) = make_generator();
        let vote = gen.generate_vote(make_hash(42));

        // Reconstruct the payload that was signed
        let mut payload = Vec::new();
        payload.extend_from_slice(vote.block_hash.as_bytes());
        payload.push(u8::from(vote.is_final));
        payload.extend_from_slice(&vote.timestamp.to_le_bytes());
        payload.extend_from_slice(&vote.sequence.to_le_bytes());

        assert!(verify_signature(&payload, &vote.signature, &pubkey));
    }

    #[test]
    fn final_vote_signature_is_valid() {
        let (mut gen, pubkey) = make_generator();
        let vote = gen.generate_final_vote(make_hash(99));

        let mut payload = Vec::new();
        payload.extend_from_slice(vote.block_hash.as_bytes());
        payload.push(u8::from(vote.is_final));
        payload.extend_from_slice(&vote.timestamp.to_le_bytes());
        payload.extend_from_slice(&vote.sequence.to_le_bytes());

        assert!(verify_signature(&payload, &vote.signature, &pubkey));
    }

    #[test]
    fn to_bytes_produces_valid_encoding() {
        let (mut gen, _) = make_generator();
        let vote = gen.generate_vote(make_hash(1));
        let bytes = vote.to_bytes();

        // Minimum size: 2 (voter_len) + voter + 32 + 1 + 8 + 8 + 64
        assert!(bytes.len() > 2 + 32 + 1 + 8 + 8 + 64);

        // Parse voter length prefix
        let voter_len = u16::from_le_bytes([bytes[0], bytes[1]]) as usize;
        assert_eq!(voter_len, vote.voter.as_str().len());
    }

    #[test]
    fn different_blocks_produce_different_signatures() {
        let (mut gen, _) = make_generator();
        let v1 = gen.generate_vote(make_hash(1));
        let v2 = gen.generate_vote(make_hash(2));

        assert_ne!(v1.signature.0, v2.signature.0);
    }

    #[test]
    fn sequence_is_monotonic_across_final_and_non_final() {
        let (mut gen, _) = make_generator();
        let v1 = gen.generate_vote(make_hash(1));
        let v2 = gen.generate_final_vote(make_hash(2));
        let v3 = gen.generate_vote(make_hash(3));

        assert_eq!(v1.sequence, 1);
        assert_eq!(v2.sequence, 2);
        assert_eq!(v3.sequence, 3);
    }
}
